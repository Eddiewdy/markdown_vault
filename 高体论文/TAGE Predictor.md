## A PPM-like, tag-based branch predictor

-----------------------

该论文介绍的TAGE预测器采用了类似于Percetron 分支预测器（PPM）的算法，即使用历史分支结果序列来预测下一个分支的结果。但与Percetron不同的是，该预测器使用tag来编码历史记录，从而避免了使用大量的内存来保存历史记录。该预测器还使用一种称为"竞争式分支预测器"的技术来解决多个预测器之间的竞争问题，即采用多个bank进行预测，从最高级到低级依次查询预测结果。

TAGE预测器的预测表由多个bank组成，每个bank都与一个预测器相关联。当一个新的分支历史记录到达时，预测器会根据该全局历史记录和PC生成一个tag，并在预测表中对应的索引进行tag的匹配。如果找到匹配的标签，则预测器将使用该标签对应的预测器来预测分支的结果。如果没有找到匹配的标签，则该级别的预测器将默认预测分支不被执行。

实验结果表明，该预测器在SPEC CPU2006和MiBench等基准测试中取得了良好的性能，与其他现有的分支预测器相比具有竞争力。该预测器还具有低功耗和低存储需求的优势，可以在嵌入式系统和移动设备等资源受限的环境中得到广泛应用。该论文还在后半部分将TAGE预测器和GPPM-idea预测器进行了对比。

### TAGE预测器的组成结构

TAGE预测器主要由两部分预测表组成，分别为双峰预测表和全局预测表。

- 双峰值预测表由PC的低12位直接索引，每一项由一个3 bits饱和计数器来提供预测结果

- 全局预测表由4个bank组成，每一个bank由PC和一个不同长度的全局历史记录共同索引，全局预测表中的每一项包括一个用于确认该全局历史记录下的PC是否命中的**8 bits的tag**以及提供预测结果的**3 bits饱和计数器**

预测器的结果由全局预测表中匹配成功的最长历史索引的bank提供，若果全局预测表都未命中，则预测方向由使用PC直接索引的双峰值预测表提供。

下图为TAGE预测器的结构图。最左侧为双峰值预测表，记为bank0，它有4K个表项，使用PC低12位直接索引，每一项包含3bits的饱和计数器和1bit的m位；右边四个bank记为bank1～4，他们为上述介绍的全局预测表，分别使用10、20、40、80bits的全局历史记录和PC一起索引，当历史长度超出索引所需的位数时，将采用折叠的方法将历史转化为所需长度，再将其与PC进行异或后对相应的bank进行索引。bank1～4均有1K项，每一项包含一个8bits的tag，3bits的饱和计数器以及一个u bit。综上预测器的大小为64Kb。

![image-20230405230429479](https://wangyidipicgo.oss-cn-hangzhou.aliyuncs.com/image-20230405230429479.png)

### 获取预测结果的方式

使用TAGE预测器进行预测时，同时访问5个bank。对于全局预测表，需要同时使用相应长度的全局历史记录和PC进行10bits全局预测表的索引计算和8bits的tag计算，计算tag的hash函数不同于计算索引的hash函数，但是输入都是相同的历史和PC。当对bank的访问结束后，可以得到bank0～4的5bit预测信息以及bank1～4的4个8bits tag信息。最终的预测信息将从由最长历史计算tag匹配的bank给出。即如果bank4使用的80bits历史索引的项tag匹配成功了，则最后的预测方向由bank4给出，否则将观察bank3是否匹配成功，以此类推。如果bank1～4都没有tag匹配成功，则最终的预测结果将有双峰值预测表即bank0给出。

**全局历史信息折叠**

在使用全局历史记录和PC一起计算索引的时候，当历史长度超出索引所需的位数时，将采用折叠的方法将历史转化为所需长度。

通常情况下进行折叠操作可以采用XORS树进行操作，例如对于40bits的历史如果需要折叠成10bits就需要两级XORS树（XORS操作默认为两输入），对于80bits的历史就需要三级的XORS树进行折叠了。但是，考虑到预测器中不是对一个随机数进行折叠，新的历史与旧的历史存在着一定的关系。所以对于全局历史的折叠可以采用循环移位寄存器CSRs的方法实现，每次只需要进行计算一位新的结果，在TAGE预测器中，对于bank2～4采用了10 bits的CSR进行索引的计算。折叠的历史将会与PC的低10位以及10-19位进行异或运算，之后将结果作为bank的索引值。对于bank1将直接只用历史的低10bits即可。
![image-20230405210424807](https://wangyidipicgo.oss-cn-hangzhou.aliyuncs.com/image-20230405210424807.png)

### 更新预测器的逻辑

当一条分支跳转指令提交后，需要对分支预测器进行更新。我们已知一条条件分支指令的预测结果来源于哪个bank，也知道预测结果是否正确。

- 更新3 bits饱和计数器：仅对提供预测信息bank中的那一项进行更新，更新方式采用传统的饱和计数器的更新方式，当最终结果为跳转时，使计数器加一；当最终结果为不跳转时，计数器减一。计数器在值为7时不进行加操作，在值为0时不进行减操作。
- 分配新的一项预测信息：当某一条分支跳转指令由bank X（X<=3)提供预测信息，并且最后发现预测错误。则需要在bank n（n>3）中分配新的一项预测信息。实际分配的规则为：访问bank n（n>X）中的u位，如果这些bank对应项的u位都为1，则随机选择一个bankY，否则选择一个u位为0的bank，对其中的项进行替换。对于上述选择的bank，需要将对应项进行重新初始化操作，初始化tag为当前分支跳转指令PC与全局历史记录计算出的tag。u位初始化为0。3 bits的饱和计数器初始化为011（弱不跳转）或者100（强跳转），具体选择哪一个需要根据bank 0中的m位来区别，如果m位为1，则重新初始化饱和计数器根据分支指令的结果来决定，如果该分支结果为跳转，则初始化为100；如果该分支结果为不跳转，则初始化为011；如果m位为0，则重新初始化饱和计数器的值由bank0的值提供，如果bank 0的方向为跳转，则初始化为100，如果bank0的方向为不跳转，则初始化为011。
- 更新双峰值预测表的m位和全局历史表的u位：如果最终的预测结果显示双峰值预测方向与全局预测表方向不同则需要对u位和m位进行更新。如果最终的预测结果正确，则将u和m位都设为1，否则都设为0。这样做的原因是：
  - 如果双峰值预测表是错的，则表示全局预测表是正确的，将u位设为1有助于防止该项被预测表的更新替换掉，将m位设为1有助于在更新饱和计数器的时候不用双峰值的结果，而使用分支跳转指令的实际结果来更新；
  - 如果双峰值预测表是对的，则表示全局预测表是错误的，将u位设置为0表示该项可以被预测器的更新替换掉。将m位设置为0表示在更新饱和计数器的时候根据双峰值表的结果来更新即可。

### 从GPPM-ideal到TAGE

该论文对GPPM-idea的定义是基于序列频率的概念。文中将程序控制流（PCF）定义为动态基本块B的有限序列（Bi），其中B是构成程序文本的所有静态基本块的集合。在GPPM-idea预测器中，包含一个序列长度均大于1的集合T。具体的预测方法是根据待预测基本块B~j~，找到T中的最长前缀，随后把这个前缀的最常出现的后继基本块作为预测结果。

GPPM-idea这种预测器需要首先对T进行挑选，挑选的方式是要使得m(T)，也就是错误预测数最少。具体选择T中序列的方法是首先构造序列长度从2\~n的集合，从中删除0~s~ =0~u~的序列，得到有用的序列集合S*作为T的选择。

从GPPM-idea预测器经过退化得到TAGE预测器的过程包括如下步骤：

| 步骤 | 退化路径                                         |
| ---- | ------------------------------------------------ |
| 1    | 仅使用分支方向作为全局历史信息                   |
| 2    | 全局历史信息不超过80位                           |
| 3    | 允许的全局历史信息的长度为10，20，40，80位       |
| 4    | 同一个长度的序列的个数不能超过1024               |
| 5    | 使用TAGE的哈希函数和序列分配                     |
| 6    | 用3 bits饱和计数器来表示最常出现的后继基本块结果 |
| 7    | 使用8位的tag                                     |
| 8    | 使用m位来初始化饱和计数器                        |
| 9    | 使用4K条目的双峰值预测器                         |

### TAGE可能的优化方法

从GPPM-ideal到TAGE的退化过程来看，如果想改进TAGE预测器，可以在几个地方尝试，上面表中的步骤1至4涉及全局历史长度的选择以及bank的数量和规模。在这里如果选择更长的全局历史信息和更多的bank，可以进一步提高正确率。同时第5步是导致GPPM-ideal和TAGE之间差异的因素之一。在TAGE中，我们会替换每个错误预测的条目。这个方法的问题在于，预测错误越多，有用的条目就越被无用的条目所取代，应该找到一个比u位更好的方法来决定哪个条目应该被替换。还应该找到一种比m位更好的方法来初始化计数器，因为这种方法是很多额外错误预测的来源，新初始化后的条目会需要更多次的分支信息才能趋于正确稳定预测。最后，我们应该尝试扩大双峰值预测器，或者找到一种方法来动态调整双峰值预测器的条目数。一些预测器比如O-GEHL，能根据应用程序动态调整历史长度，能取得比普通TAGE更好的效果，所以TAGE也可以在这方面进一步优化。