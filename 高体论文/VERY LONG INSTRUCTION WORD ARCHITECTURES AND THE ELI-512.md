### VERY LONG INSTRUCTION WORD ARCHITECTURES AND THE ELI-512

这篇论文主要研究了基于trace scheduling技术进行的VLIW体系结构的计算机系统设计。VLIW是一种并行计算架构，在单个指令流中执行多个静态计划的、紧密耦合的、精细的操作。之前设计的VLIW体系结构的计算机大多都没有发现足够的指令并行，值达到最大2-3倍的性能提升，之前的研究都没有很好的办法在跨越基本快的情况下发掘并行性。使用trace scheduling技术可以从程序片段中探索更多的并行性，找到足够多的并行代码来支持VLIW的执行，trace scheduling不能适用所有的代码程序，但它适用于大多数一般科学计算的场景。同时这篇论文也给出了基于trace scheduling的一个VLIW的计算机的具体设计，ELI-512。ELI-512，"ELI"代表Enormously Longword Instructions，是这种VLIW机器的一个实例，它的水平指令字超过500位，预计每个周期将执行10到30个RISC级操作。实际上，当前的设计有一个1200位的指令字。

下面的内容，将分为几个部分对这篇论文进行介绍

#### VLIW的定义

VLIW包含以下的一些性质：

- 每个周期有一个中央控制单元发出一条长指令。
-  每条长指令由许多紧密耦合的独立操作组成。
-  每个操作都需要少量的、静态可预测的周期数来执行。
-  操作可以被流水

#### VLIW相比于向量机的优点

尽管向量机比之前的VLIW能够提供更多的并行性，但是向量机只能加速内部循环，同时需要特殊的编程模型，文章认为向量机在科学计算上取得进一步突破的可能性不大。对向量机进行编程，编译器或手工编码器必须使代码中的数据结构几乎完全符合硬件内置的常规结构。如果说低级代码必须由程序员进行重写，那么会使得通用性大大降低。

#### trace schduling技术


trace schduling这种编译技术基于以下的关键概念：

1. **基本块**：基本块是一个没有跳转指令的指令序列。编译器通常在基本块级别上进行一些基本的优化，如常数传播，删除无用代码等。
2. **跟踪（Trace）**：跟踪是一种预测执行路径，它是程序中可能经常执行的一系列基本块。跟踪的选择可能基于静态分析，也可能基于以前的运行时行为。

VLIW的关键是，编译器而非处理器负责解决指令级并行性的问题，包括数据依赖性和资源冲突等。由于编译器在生成指令序列时有完全的全局视图，所以它通常能更好地解决这些问题。

Trace Scheduling是一种用于改善VLIW的一种编译器调度策略，由Fisher在1981年首次提出。它的核心概念是"trace"，即程序执行中的一条可能的路径。编译器会识别出程序中的热点路径（即最可能被执行的路径）并尽可能优化这些路径，使其在VLIW架构上达到最大的并行性。

具体设计包括以下步骤：

1. **Trace Selection**：首先，编译器需要选择出执行最频繁的路径（即trace）。这通常通过基于分支预测的启发式方法完成，对可能的执行路径进行权衡。重要的是，这个过程可能需要反复进行，以处理那些路径选择相互影响的情况。
2. **Trace Scheduling**：编译器然后会对所选择的trace进行调度，使得在trace内部可以尽可能地并行执行操作。调度时，编译器会尽量减少依赖关系和资源冲突，将可以并行的操作放在同一个VLIW指令中。这个过程中，可能会涉及到代码的移动，即将代码从trace的一个位置移动到另一个位置。移动代码时需要处理的问题包括操作的依赖关系、可能的异常、以及影响程序正确性的其他因素。
3. **Bookkeeping**：调度后，编译器需要对trace以外的代码进行处理，以保证程序的正确性。这可能包括插入补偿代码（compensation code）以处理因为代码移动而可能出现的问题，以及处理那些从trace以外进入或退出trace的分支。

Trace Scheduling的主要挑战在于处理复杂的控制流和数据依赖关系，而这正是VLIW架构需要编译器解决的问题。尽管这样会增加编译器的复杂性，但是由于在程序运行时能够省去大量的处理器资源，因此对于某些类型的程序，特别是那些包含大量可并行操作的程序，VLIW和Trace Scheduling都可以提供非常好的性能。trace scheduling也可能会导致代码膨胀，因为可能需要插入额外的指令来处理跟踪的跳入和跳出。此外，trace scheduling的成功在很大程度上依赖于跟踪选择的准确性。如果编译器错误地预测了最常执行的路径，那么优化可能会适得其反，反而导致性能下降。

#### Bulldog编译器

这个编译器主要包括五个主要模块。第一个代码生成器是针对一个理想化的VLIW（Very Long Instruction Word）机器，可以在一个周期内执行所有RISC（Reduced Instruction Set Computing）级别的操作并在一个周期内执行无限的内存访问。

编译器的前端会生成RISC级别的中间代码，N-address code（NADDR）。其输入是一种叫做Tiny-Lisp的语言，这是一种快速构建的，以便提供最大的灵活性的FORTRAN、C、Pascal级别的语言。

"Bulldog"还实现了内存反别名（Memory Anti-aliasing）技术。追踪调度需要执行大量的代码移动，以便用来自程序广泛分布的地方的操作填充指令。代码移动受数据优先性的限制。例如，如果有一个步骤修改了数组引用的值，那么必须保证这个步骤在使用该值的任何步骤之前执行。这就涉及到了判断数组引用是否存在别名的问题。

```c++
Z = A[expr1] + X
A[expr2] = Y + W
```

Bulldog编译器中实现的系统试图解决expr1 = expr2这个方程。它使用到达定义（Reaching Definitions）来缩小表达式中每个变量的范围。我们可以假设这些变量都是整数，并使用一个丢番图方程求解器来确定它们是否可能相同。此编译器的速度提升在5到10的范围内。

#### ELI-512

ELI-512 有 16 个集群，每个集群包含一个 ALU 和一些存储单元。 这些集群呈圆形排列，每个集群都与其最近的邻居通信，有些集群与距离较远的集群通信。ELI 使用其 500+ 位指令字在每个指令周期中启动以下所有操作：

- 10 个 ALU 操作。  8 将是 32 位整数运算，而 8 将使用 64 位 ALU 进行各种操作，包括流水线浮点计算。 
- 8 个流水线内存引用
- 32 个寄存器
- 数据移动
- 基于多个独立测试的多路条件跳转

ELI的16个集群分为8个M集群和8个F集群，每个集群都包括：多端口整数寄存器组，有限的集群交叉开关，参与集群不超过 8 个。M集群还包括一个局部内存空间和一个整数ALU单元，F集群还包括一个浮点ALU单元。

#### n+1路跳转机制

这段论文主要讨论了VLIW（Very Long Instruction Word）架构中的跳转机制。在VLIW架构中，每个周期内包含大量操作，需要执行多个测试并根据这些测试结果跳转到不同的位置。但并非任何多向跳转机制都能满足这一需求。

VLIW需要的跳转机制可以基于n个独立条件进行2^n路跳转，但实际上，通过实施跟踪调度（trace scheduling），发现需要的是一个根据n个独立测试的结果跳转到任何n+1个位置的机制。跳转操作类似于LISP中的COND语句。例如：

```lisp
(COND
  (test1 label1)
  (test2 label2)
  (testn labeln)
  (SUCCEED label-fall-through)
)
```
在此结构中，如果第一个测试`test1`失败（FAIL），则在跟踪中保持状态并进行第二个测试`test2`。如果所有的测试都失败，最后将到达指令中的最后地址并跳转。这样，我们发现n+1个目标标签就足够了，没有必要使用2^n个。

在实现中，我们需要一个优先级编码器和n个测试复用器来构建一个n+1路跳转机制。但是，如何实际生成下一个地址呢？我们可以在每个指令中完全放置n+1个候选地址。例如，如果n=3，且当前指令的下一指令地址字段为00000011，则我们有以下情况：

```
测试条件  地址如果测试是第一个成功的
0   test1   00 00000011
1   test2   01 00000011
2   test3   10 00000011
3   SUCCEED 11 00000011
```

如果在一个周期中进行的测试少于n个，作者也提出了一种解决方案：引入一个始终成功的测试和一个始终失败的测试。这样，我们可以使两个想要打包一个测试的指令共享一个地址切片，或者我们可以将想要执行两个测试的指令和不想执行任何测试的指令打包在一起。通过这种方法，我们可以避免浪费未使用的插槽。总的来说，论文提出了一个灵活的，基于条件的多向跳转机制

#### bank预测

VLIW编译器需要预测内存bank，因为在每个周期内，很多操作都会涉及到内存的引用。为了在同一时钟周期内完成多个内存引用，编译器需要查看代码并预测每个引用可能涉及的内存bank。这样，可以针对预测出的bank使用专门的地址寄存器进行引用，且因为地址的路径不会交叉，所以不需要进行仲裁。

预测内存bank的精度取决于代码的静态特性和编译器的能力。在很多情况下，例如对标量的引用，bank位置总是已知的。对于数组的引用，通过反别名处理和循环展开（unrolling），也可以在很大程度上预测出引用所在的bank。

然而，有时我们可能无法预测引用的bank地址。例如，追踪指针时可能需要访问整个内存地址空间。此时，可以设计一个备用的内存访问系统来处理这类访问，这就要求内存bank具有双端口和锁定功能。

另一个问题是，即使对于数组，即使循环已经适当地展开，我们也可能无法预测子脚本的bank位置。例如，子脚本值可能取决于具有数据依赖起始点的循环索引变量。解决方法是让编译器建立一种预循环，当未知变量达到某个已知值时，预循环就会退出。例如下面的例子：

```python
(a)
for i in range(k, n+1):
    loop_body()

(b)
i = k
while True:
    loop_body()
    if i >= n:
        break
    i += 1

    loop_body()
    if i >= n:
        break
    i += 1

    loop_body()
    if i >= n:
        break
    i += 1

    loop_body()
    if i < n:
        continue
    else:
        break

(c)
B = num_banks()  # 假设num_banks()函数返回bank的数量

i = k
while True:
    while i % B != 0:
        loop_body()
        i += 1
        if i > n:
            break
    if i > n:
        break

    loop_body()
    if i >= n:
        break
    i += 1

    loop_body()
    if i >= n:
        break
    i += 1

    loop_body()
    if i >= n:
        break
    i += 1

    loop_body()
    if i < n:
        continue
    else:
        break
 
```

(a) 表示源代码中的循环。注意我们使用了FORTRAN风格的循环，即在循环末尾进行判断。

(b) 这里展示了循环的展开（unwinding）。在循环展开中，原始循环中的主体会被复制多次，这样在每个循环迭代中就可以并行执行多个操作。

(c) 在这部分中，我们添加了一个预循环。预循环会执行直到I成为银行数量的模数（即I模B等于0）。在预循环内，一旦I满足条件，我们就跳到主循环。预循环的目的是处理那些无法预测的引用，并将这些引用处理到可以预测的状态。然后主循环接管执行，因为在主循环中，所有的引用都能被成功预测。

总的来说，VLIW的bank预测是一个结合了编译器技术和硬件设计的策略，旨在最大化并行内存访问的效率，同时处理可能的bank冲突和不可预测的内存引用。

#### 总结

这篇论文的主要贡献在于解决了使用超长指令字(VLIW)架构来加速科学计算，主要研究的问题包括高度并行的代码生成，每个周期中的多重条件跳转，以及每个周期中的多重内存引用。

1. Bulldog编译器：开发了一种新的编译器，它能够从科学代码中提取出大量的并行性，这证明了使用VLIW架构的价值。

2. ELI-512：设计并正在构建一个VLIW的处理器，其指令字长度超过500位，预计可以将科学代码的执行速度提高10-30倍。

3. 高效的代码生成与管理策略：使用了追踪调度，n+1路跳转机制，预测存储器bank，本地搜索优先级，和预循环等技术，以在不过度扩大机器的情况下，在每个周期中调度足够的测试和内存引用。

4. 针对科学计算的专门优化：设计了针对计算密集型科学代码的优化策略，使得VLIW并行性能够得到扩展并提升代码的执行性能。
