### The Tera Computer System

#### Tera架构

在这篇论文中，作者详细介绍了Tera架构的设计理念、特征以及实现技术，这是一款重视高速执行、适应性的系统，旨在实现易于编译器实现的架构。Tera架构的主要特点包括其能够扩展到多处理器，实现极短的时钟周期，以及具有多样化应用领域的能力。这篇报告将按照论文的章节进行描述，并解释相关的技术细节。

Tera架构设计的主要目标是为了适应非常高速的执行，也就是说，它允许极短的时钟周期，并且能够扩展到多个处理器。文中指出，虽然具体的实现可能无法无限扩展，但是抽象架构可以无限扩展。Tera架构要求指令流的数量比物理处理器的数量增加得更快，这意味着虽然随着指令流数量的增加，加速效果呈现出亚线性，但它仍然可以随着物理处理器数量的增加而线性增加。Tera架构的性价比很好，使得高性能的实现在经济上可行。

Tera架构还需要广泛的适用性。只要有足够的并行性来保持处理器的忙碌，那些不适合向量化的程序（可能是由于标量操作过多或者条件分支过于频繁）也能够有效地执行。Tera架构中可以将几乎所有的并行性转化为速度，从程序基本块内的操作级并行性到多用户的时间和空间共享。

#### 互联网络

论文的另一个重点是互连网络，这是一个由管道分组交换节点组成的三维网格，每个节点都与它的一些邻居节点相连接。每个链接都可以在每个时钟同时在两个方向上传输包含源和目标地址、操作码和64位的分组。一些节点还与资源相连接，例如处理器、数据内存单元、I/O处理器和I/O缓存单元。资源并非位于网络的一侧，而是更多地均匀分布在网络中，这允许数据在可能的情况下被放置在接近适当处理器的内存单元中，并在其他情况下最大化可能产生干扰的资源之间的距离。

完全配置的系统包含512个数据存储单元，每个存储单元有128GB的存储。内存是按字节寻址的，并以64位的字组织。每个字都关联有四个额外的访问状态位。数据和访问状态各自配备了一套单错误纠正、双错误检测的代码位。处理器使用与RP3类似的方案对数据地址进行随机化，这种随机化非常适合避免内存bank热点和网络拥塞，但使得利用附近的内存单元来提高内存局部性更加困难。在Tera系统中，随机化与分布的概念结合在一起。处理器的数据段映射为每个段条目关联了一个分布因子。在一个段内连续的虚拟地址可以在所有512个数据内存单元之间进行分布，可以只在一个单元中，也可以在两者之间的任何一个2的幂次之间。

#### 处理器和内存

由于近年来磁盘速度没有跟上处理器和内存性能的提高，因此必须在磁盘和数据内存之间放置一个大的内存，以降低磁盘在内存层次中的级别。在完全配置的Tera系统中，从二级存储到数据内存所需的70GB/秒的持续带宽由256个I/O缓存单元提供，这些单元组成了一个直接可寻址的256GB的内存。I/O缓存单元在功能上与数据内存完全相同，唯一的区别是它们的延迟更高。

在Tera计算机系统中，每个处理器都能同时执行多条指令流。在当前的实现中，同时活跃的程序计数器可能少至一个，多至128个。每个时钟周期，处理器逻辑选择一个准备好执行的流，让它发出下一条指令。由于指令解释完全由处理器以及网络和内存进行流水线处理，因此每个时钟周期可能从不同的流发出一条新指令，而不会干扰其前面的指令。当一条指令完成时，该指令所属的流就准备好执行下一条指令。只要处理器中有足够的指令流，以便用其他流的指令填充平均指令延迟，处理器就被完全利用。因此，只需要有足够的流来隐藏预期的延迟（平均可能需要70个时钟周期）；一旦隐藏了延迟，处理器就在达到峰值性能运行，额外的流不会加速结果。如果一个流在上一条指令完成之前不允许发出下一条指令，那么每个处理器大约需要70个不同的流来隐藏预期的延迟。

Tera采用的是水平指令。水平指令是一种一次指定多个操作的指令。对于内存操作，通常是简单的加载和存储，其他操作则是两个或三个地址的寄存器到寄存器的操作。这种设计克服了发出多于一条指令的困难，而这正是处理器效率受限的主要因素，即所谓的Flynn瓶颈。

显式依赖展望是Tera架构的一种新技术，用于解决如何有效控制指令展望（lookahead）的问题。每条指令都包含一个三位的展望字段，明确指定从当前指令流发出的指令数量，直到遇到一个依赖于当前指令的指令。当所有具有展望值的指令都完成时，流就准备好发出新的指令。

总体而言，Tera架构展示了如何通过同时处理多个指令流、保存每个流的状态、使用水平指令以及实现显式依赖展望来提高处理器的性能。这些设计使得Tera处理器能够更好地利用硬件资源，提高处理器的性能，提高程序的运行效率。

Tera的每个处理器支持最多16个活动保护域，用于定义程序内存，数据内存和分配给使用该处理器的计算的流的数量。保护域共享一个64K的数据段映射和一个16K的程序页映射。保护域的数量由slim，scur，和sres三个参数控制。这些域提供了内存引用重试限制，这是一个允许在满/空位测试失败后陷阱的次数。Tera系统设有四个权限级别：用户，监督员，内核和IPL。每个级别都具有相应的权限，数据映射条目定义了读取和写入每个段所需的最低级别，程序映射条目定义了从每个页面执行的确切级别。为了允许执行流更改其权限级别，系统提供了两种硬件操作：LEVEL-ENTER和LEVEL-RETURN。

#### 一些其它设计

论文还探讨了异常的处理。在Tera架构中，有些异常被定义为指令完成的副作用，以此模型，所有可能的异常都将在开始执行依赖于其的指令之前发出。另外，有两种情况可以引发异常：一种是由于权限不足而无法执行指令，另一种则是在执行指令时发生。

论文也提到了标记内存。Tera计算机系统中的每个内存位置除了具有64位值外，还有四个访问状态位。这些访问状态位能让硬件实现几种对常规内存引用语义的有用修改，如应用特定的轻量级陷阱，实现隐形间接寻址，以及轻量级同步。

Tera系统中的内存具有一种叫做"full/empty"位的特性，用于轻量级的同步。根据访问控制字段的设定，载入和存储操作可以选择性地使用内存单元的full/empty位。四种访问控制值分别对应了不同的读取和写入策略。此外，对于需要执行“向内存添加整数”的操作，Tera架构使用FETCH-ADD操作，这个操作在每个内存单元内部完成，以实现极短的互斥时间。

#### 总结

这篇论文详细讨论了Tera计算机系统的处理器的设计和工作原理，包括指令流、流状态、水平指令、显式依赖展望、保护域和特权级别等概念。这些设计思想和技术细节展示了Tera处理器的并行处理能力，其设计目标是提高本地性和避免重新加载数据。论文中提到的新技术，如显式依赖forward，为处理器的并行性能提供了新的可能性。