## An Efficient Algorithm for Exploiting Multiple Arithmetic Units 读书报告

------------------------

### 论文主要思想

在计算机科学中，如何利用计算机系统中的多个算术运算单元并行地执行计算任务是一个重要的问题。尽管许多计算机处理器都具有多个算术运算单元，但是在实际应用中往往无法完全发挥这些单元的性能。这是因为许多算法和程序往往是串行的，无法充分利用计算机系统中的多个算术运算单元。此外，即使有并行计算的需求，设计高效的并行算法也是非常困难的。因此，提高计算机系统的并行性能一直是计算机科学领域的热门话题之一。

本文所介绍的算法旨在解决这一问题。该算法可以有效地利用多个算术运算单元并行地执行计算任务，从而提高计算机系统的性能。该算法不仅可以应用于单个计算机处理器上，还可以扩展到多个处理器或分布式系统中。

#### 寄存器状态保存表（busy 位）

文章分为几个部分，第一部分讨论了物理寄存器的结构，数据通路，执行单元的设计。

在第一部分中，文章首先说明了在 IBM System/360 指令单元在将指令送入FLOS中时，会将存储-寄存器指令、寄存器-寄存器指令都映射为pseudo寄存器-寄存器指令。指令中 R1 永远都是来源于4个浮点寄存器堆中（FLR），而 R2 则会根据不同的指令，表示浮点缓冲区（FLB）、浮点寄存器堆（FLR）和存储缓冲区（SDB）中的相应内容。

随后针对顺序代码执行过程中**读后写**所导致的流水线堵塞，后续数据不相关的指令无法被译码和发射的问题，文章提出了给 FLR 的每一个寄存器设置 busy 位的方法，同时在执行单元前面增加保留站（RS），对于一条的指令发射到 RS 后，会将源寄存器的 busy 位置位，执行完毕后写回寄存器时把 busy 位清零。这样使得后续数据不相关的指令在源操作数和目的操作数不是 busy 的时候可以直接被发射到执行单元执行，而对于源寄存器 busy 的指令则在 RS 中等待寄存器的就绪。但是这种方法对于某些顺序对单一寄存器进行操作的代码段起不到很好的优化作用。比如下面的例子：

```assembly
LOOP 1	LD F0, Ei
                MD F0, Di
                AD F0, Ci
                AD F0, Bi
                AD F0, Ai
                STD F0, Fi
                BXH i, -1, 0, LOOP 1
```

在这个例子中我们无法使用到之前的设计所带来的性能提升，因为我们所有的后续指令都有相同的源寄存器和目的寄存器，这样导致必须等上一个结果写会寄存器堆栈，然后再传个 RS 后，下一条指令才可以得到执行。

#### CDB总线设计

针对这个问题，文章又提出了 Common Data Bus (CDB) 的设计，CDB 不仅会把运算器得到的结果输送给寄存器堆，同样也会给保留站中的所有源寄存器和目的寄存器，同时 FLB 的数据可以直接通过 CDB 传递给其他的位置，这样使得 load 可以不经过存储到寄存器这一步直接将数据给需要用的位置。CDB 由所有可以更改寄存器的单元提供，并且它可以给所有以寄存器作为操作数的单元提供数据。为了区别 CDB 中不同的数据来源，每一个寄存器都需要添加一个 tag 标志。具体的 tag 设置方法是，在每条指令解码时，FLOS 检查每个指定浮点寄存器的 busy 位。 如果该位为零，则寄存器的内容可以通过 FLR 总线传送到相应的单元。 在发出指令时，只需要一个计算单元是空闲的，FLOS 不仅设置目的寄存器的 busy 位，而且还将其 tag 设置为所发射到的单元的对应 tag。 源寄存器控制位保持不变。 以指令 AD FO, FLB1 为例。 向加法器 1 发出此指令后，FO 的控制位将是：

```assembly
BB		     TAG
1			1010(A1)
```

对于之前只使用 busy 位来说，加入 tag 之后可以解决之前的问题，只需要在下一条指令译码的时候，将对应目的寄存器的 tag 位覆盖，是的前一条指令执行完之后的结果不会写会寄存器堆。

```assembly
BB		     TAG
1			1011(A2)
```

下图是加上 CDB 后的整体数据通信设计图

![image-20230318165152414](https://wangyidipicgo.oss-cn-hangzhou.aliyuncs.com/image-20230318165152414.png)



### 优点与不足

Tomasulo算法1966年提出，设计目标是让编译器在360系列计算机中通用，不用为每台计算机专门做一个编译器。Tomasulo成功地解决了三种冒险，实现了指令的乱序执行，且性能比记分牌更好，具体优化的地方有如下几点：

- 记分牌算法每条通路只能存一条指令，导致经常有指令因为结构冒险而不能发射，**而Tomasulo引入保留站之后每条通路可以缓冲下多条指令，这样的做法平缓了指令发射的速度**。
- 写后写冒险时，记分牌过度纠结寄存器名字，会把所有指令的结果都写进寄存器堆，会因为写后写冒险阻塞指令发射，而Tomasulo只保存最新的写入值，这样即保证了正确的结果，又减少了无谓的工作。
- 读后写冒险时，记分牌过度纠结寄存器名字，指令在执行之前一直检测的是寄存器堆，一旦数据准备好，就会从寄存器堆中取数，这样的后果就是后序指令即使计算完结果也可能不能立刻写回寄存器堆，而Tomasulo则在发射时就拷贝数据，贯彻数据流的思想。
- 在写后读冒险中CDB总线实现了逻辑上的正确。

但是文章提出的 Tomasulo 算法也不是完美的，它也存在一些问题。Tomasulo 算法中每一个执行单元对应一个保留站，保留站中缓冲多条指令，所以有可能在同一周期有多条指令准备好数据，但是执行单元同时只能执行一条指令，所以就需要从中选择一条指令，简单的解决办法是为保留站的每一行增加一个年龄位，每次出现冲突，就选择最老的指令送到执行单元。

在文章中的举例中，CDB 总线只有一组，**这意味着每一个周期只能写回一条指令**，如果同时有多条指令完成，那就只能选择一条指令进行广播，别的指令等待。第二种办法是增加CDB总线，支持多指令广播，但是这会让电路面积大增，包括增加寄存器堆写口、增加保留站tag和CDB总线的比较电路、增加保留站写口。同时文章的例子中几乎只关注了逻辑运算单元的保留站，**但是存储指令之间也会发生数据冲突**，这也需要增加控制逻辑来正确调度指令。

同时基础的 Tomasulo 算法不能保证Precise Exception，要支持精确中断，就要确保指令按序提交。因为没有使用 reorder buffer (rob) 来做到按序提交，这也是本篇文章没有考虑到的地方。在不带ROB的版本里，执行单元产出的数据会直接写入到对应的寄存器堆和等待这个数据的 RS 中，不能实现Precise exception和 HW Speculation。因此在此基础上，我这里也对实现了 rob 的 Tomasulo 算法进行的调研，ROB的存在使得指令虽然乱序执行，但是必须顺序提交，防止不可撤销的更新操作发生（写寄存器，写内存）。

<img src="https://wangyidipicgo.oss-cn-hangzhou.aliyuncs.com/v2-3d71c43a1f3c519ce8748c02e5eab2d3_720w.webp" alt="img" style="zoom:75%;" />

### 总结

Tomasulo 算法由 IBM 公司在 1967 年提出，提出寄存器重命名的方法解决了 WRW 、RAW 冒险，这比拘泥于寄存器编号的记分牌算法更加优越，该文章提出的算法为后来的乱序执行处理器提供了一个非常广阔的方向，因此后来的乱序机器大都学习了IBM公司的做法，在今天的处理器设计中，乱序执行和重命名已经成为了高性能处理器的标准设计。但是 Tomasulo 算法也有一些问题，包括 CDB 总线的争用导致的延时等问题，其中最严重的是其不能支持精确中断，这为分支指令的处理和程序员调试程序带来了巨大的麻烦，因此后来的设计人员设计出重排序缓冲的概念来改进Tomasulo。



参考文献：

1. Tomasulo R M. An efficient algorithm for exploiting multiple arithmetic units[J]. IBM Journal of research and Development, 1967, 11(1): 25-33.
2. https://zhuanlan.zhihu.com/p/499978902











